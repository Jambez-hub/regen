// GENERATED AUTOMATICALLY. DO NOT EDIT THIS FILE: IT WILL BE OVERWRITTEN.

#ifndef _MAIN_GEN_HPP_
#define _MAIN_GEN_HPP_

#include "main.hpp"

/** enum: auto-generated from main.hpp:7: C4_ENUM: TestEnum_e */
#include "enum.hpp"

template<> const EnumSymbols< TestEnum_e > esyms();
template<> inline size_t eoffs_pfx< TestEnum_e >()
{
    // same as strlen("TE_")
    return 3;
}

/** enum: auto-generated from main.hpp:14: C4_ENUM: TestEnumClass_e */
#include "enum.hpp"

template<> const EnumSymbols< TestEnumClass_e > esyms();
template<> inline size_t eoffs_cls< TestEnumClass_e >()
{
    // same as strlen("TestEnumClass_e::")
    return 17;
}
template<> inline size_t eoffs_pfx< TestEnumClass_e >()
{
    // same as strlen("TestEnumClass_e::TEC_")
    return 21;
}

/** serialize: auto-generated from main.hpp:29: C4_CLASS: TestStruct */
#include "serialize.hpp"

namespace c4 {
template <>
struct serialize_category< TestStruct >
{
    enum : int { value = SerializeCategory_e::CUSTOM };
};
template <class Stream>
struct srlz_custom< TestStruct, Stream >
{
    static void s(Archive< Stream > &a, const char* name, TestStruct *var)
    {
        serialize< float >(a, "x", &var->x);
        serialize< float >(a, "y", &var->y);
        serialize< float >(a, "z", &var->z);
    }
    static void s(Archive< Stream > &a, const char* name, TestStruct *var, size_t num)
    {
        a(name, var, num);
    }
};
} // end namespace c4
/** imgui: auto-generated from main.hpp:29: C4_CLASS: TestStruct */


// TestStruct
/** serialize: auto-generated from main.hpp:35: C4_CLASS: TestTpl<T> */
#include "serialize.hpp"

namespace c4 {
template <class T>
struct serialize_category< TestTpl<T> >
{
    enum : int { value = SerializeCategory_e::CUSTOM };
};
template <class T, class Stream>
struct srlz_custom< TestTpl<T>, Stream >
{
    static void s(Archive< Stream > &a, const char* name, TestTpl<T> *var)
    {
        serialize< T >(a, "r", &var->r);
        serialize< T >(a, "g", &var->g);
        serialize< T >(a, "b", &var->b);
        serialize< T >(a, "a", &var->a);
    }
    static void s(Archive< Stream > &a, const char* name, TestTpl<T> *var, size_t num)
    {
        a(name, var, num);
    }
};
} // end namespace c4
/** imgui: auto-generated from main.hpp:35: C4_CLASS: TestTpl<T> */


// TestTpl<T>
/** serialize: auto-generated from main.hpp:41: C4_CLASS: TestTpl2<T, U> */
#include "serialize.hpp"

namespace c4 {
template <class T, class U>
struct serialize_category< TestTpl2<T, U> >
{
    enum : int { value = SerializeCategory_e::CUSTOM };
};
template <class T, class U, class Stream>
struct srlz_custom< TestTpl2<T, U>, Stream >
{
    static void s(Archive< Stream > &a, const char* name, TestTpl2<T, U> *var)
    {
        serialize< T >(a, "x", &var->x);
        serialize< U >(a, "y", &var->y);
    }
    static void s(Archive< Stream > &a, const char* name, TestTpl2<T, U> *var, size_t num)
    {
        a(name, var, num);
    }
};
} // end namespace c4
/** imgui: auto-generated from main.hpp:41: C4_CLASS: TestTpl2<T, U> */


// TestTpl2<T, U>
/** serialize: auto-generated from main.hpp:48: C4_CLASS: TestTpl3<T, U, V> */
#include "serialize.hpp"

namespace c4 {
template <class T, class U, class V>
struct serialize_category< TestTpl3<T, U, V> >
{
    enum : int { value = SerializeCategory_e::CUSTOM };
};
template <class T, class U, class V, class Stream>
struct srlz_custom< TestTpl3<T, U, V>, Stream >
{
    static void s(Archive< Stream > &a, const char* name, TestTpl3<T, U, V> *var)
    {
        serialize< T >(a, "x", &var->x);
        serialize< U >(a, "y", &var->y);
        serialize< V >(a, "z", &var->z);
    }
    static void s(Archive< Stream > &a, const char* name, TestTpl3<T, U, V> *var, size_t num)
    {
        a(name, var, num);
    }
};
} // end namespace c4
/** imgui: auto-generated from main.hpp:48: C4_CLASS: TestTpl3<T, U, V> */


// TestTpl3<T, U, V>
/** serialize: auto-generated from main.hpp:56: C4_CLASS: TestTpl4<T, U, V, N> */
#include "serialize.hpp"

namespace c4 {
template <class T, class U, class V, int N>
struct serialize_category< TestTpl4<T, U, V, N> >
{
    enum : int { value = SerializeCategory_e::CUSTOM };
};
template <class T, class U, class V, int N, class Stream>
struct srlz_custom< TestTpl4<T, U, V, N>, Stream >
{
    static void s(Archive< Stream > &a, const char* name, TestTpl4<T, U, V, N> *var)
    {
        serialize< T [N] >(a, "x", &var->x);
        serialize< U [N] >(a, "y", &var->y);
        serialize< V [N] >(a, "z", &var->z);
    }
    static void s(Archive< Stream > &a, const char* name, TestTpl4<T, U, V, N> *var, size_t num)
    {
        a(name, var, num);
    }
};
} // end namespace c4
/** imgui: auto-generated from main.hpp:56: C4_CLASS: TestTpl4<T, U, V, N> */


// TestTpl4<T, U, V, N>
/** serialize: auto-generated from main.hpp:64: C4_CLASS: TestTpl51<T, U, V, N, AAA> */
#include "serialize.hpp"

namespace c4 {
template <class T, class U, class V, int N, template<class> class  AAA>
struct serialize_category< TestTpl51<T, U, V, N, AAA> >
{
    enum : int { value = SerializeCategory_e::CUSTOM };
};
template <class T, class U, class V, int N, template<class> class  AAA, class Stream>
struct srlz_custom< TestTpl51<T, U, V, N, AAA>, Stream >
{
    static void s(Archive< Stream > &a, const char* name, TestTpl51<T, U, V, N, AAA> *var)
    {
        serialize< T [N] >(a, "x", &var->x);
        serialize< U [N] >(a, "y", &var->y);
        serialize< V [N] >(a, "z", &var->z);
        serialize< AAA<T> >(a, "w", &var->w);
    }
    static void s(Archive< Stream > &a, const char* name, TestTpl51<T, U, V, N, AAA> *var, size_t num)
    {
        a(name, var, num);
    }
};
} // end namespace c4
/** imgui: auto-generated from main.hpp:64: C4_CLASS: TestTpl51<T, U, V, N, AAA> */


// TestTpl51<T, U, V, N, AAA>
/** serialize: auto-generated from main.hpp:73: C4_CLASS: TestTpl52<T, U, V, N, AAA> */
#include "serialize.hpp"

namespace c4 {
template <class T, class U, class V, int N, template<class, class> class  AAA>
struct serialize_category< TestTpl52<T, U, V, N, AAA> >
{
    enum : int { value = SerializeCategory_e::CUSTOM };
};
template <class T, class U, class V, int N, template<class, class> class  AAA, class Stream>
struct srlz_custom< TestTpl52<T, U, V, N, AAA>, Stream >
{
    static void s(Archive< Stream > &a, const char* name, TestTpl52<T, U, V, N, AAA> *var)
    {
        serialize< T [N] >(a, "x", &var->x);
        serialize< U [N] >(a, "y", &var->y);
        serialize< V [N] >(a, "z", &var->z);
        serialize< AAA<T, U> >(a, "w", &var->w);
    }
    static void s(Archive< Stream > &a, const char* name, TestTpl52<T, U, V, N, AAA> *var, size_t num)
    {
        a(name, var, num);
    }
};
} // end namespace c4
/** imgui: auto-generated from main.hpp:73: C4_CLASS: TestTpl52<T, U, V, N, AAA> */


// TestTpl52<T, U, V, N, AAA>
/** serialize: auto-generated from main.hpp:82: C4_CLASS: TestTpl53<T, U, V, N, AAA> */
#include "serialize.hpp"

namespace c4 {
template <class T, class U, class V, int N, template<class, class, class> class  AAA>
struct serialize_category< TestTpl53<T, U, V, N, AAA> >
{
    enum : int { value = SerializeCategory_e::CUSTOM };
};
template <class T, class U, class V, int N, template<class, class, class> class  AAA, class Stream>
struct srlz_custom< TestTpl53<T, U, V, N, AAA>, Stream >
{
    static void s(Archive< Stream > &a, const char* name, TestTpl53<T, U, V, N, AAA> *var)
    {
        serialize< T [N] >(a, "x", &var->x);
        serialize< U [N] >(a, "y", &var->y);
        serialize< V [N] >(a, "z", &var->z);
        serialize< AAA<T, U, V> >(a, "w", &var->w);
    }
    static void s(Archive< Stream > &a, const char* name, TestTpl53<T, U, V, N, AAA> *var, size_t num)
    {
        a(name, var, num);
    }
};
} // end namespace c4
/** imgui: auto-generated from main.hpp:82: C4_CLASS: TestTpl53<T, U, V, N, AAA> */


// TestTpl53<T, U, V, N, AAA>
/** serialize: auto-generated from main.hpp:91: C4_CLASS: TestTpl54<T, U, V, N, AAA> */
#include "serialize.hpp"

namespace c4 {
template <class T, class U, class V, int N, template<class, class, class, int> class  AAA>
struct serialize_category< TestTpl54<T, U, V, N, AAA> >
{
    enum : int { value = SerializeCategory_e::CUSTOM };
};
template <class T, class U, class V, int N, template<class, class, class, int> class  AAA, class Stream>
struct srlz_custom< TestTpl54<T, U, V, N, AAA>, Stream >
{
    static void s(Archive< Stream > &a, const char* name, TestTpl54<T, U, V, N, AAA> *var)
    {
        serialize< T [N] >(a, "x", &var->x);
        serialize< U [N] >(a, "y", &var->y);
        serialize< V [N] >(a, "z", &var->z);
        serialize< AAA<T, U, V, N> >(a, "w", &var->w);
    }
    static void s(Archive< Stream > &a, const char* name, TestTpl54<T, U, V, N, AAA> *var, size_t num)
    {
        a(name, var, num);
    }
};
} // end namespace c4
/** imgui: auto-generated from main.hpp:91: C4_CLASS: TestTpl54<T, U, V, N, AAA> */


// TestTpl54<T, U, V, N, AAA>
/** serialize: auto-generated from main.hpp:100: C4_CLASS: ThisIsATest */
#include "serialize.hpp"

namespace c4 {
template <>
struct serialize_category< ThisIsATest >
{
    enum : int { value = SerializeCategory_e::CUSTOM };
};
template <class Stream>
struct srlz_custom< ThisIsATest, Stream >
{
    static void s(Archive< Stream > &a, const char* name, ThisIsATest *var)
    {
        serialize< bool >(a, "bdata", &var->bdata);
        serialize< char >(a, "mode_data", &var->mode_data);
        serialize< int >(a, "prop", &var->prop);
        serialize< int >(a, "prop2", &var->prop2);
        serialize< float >(a, "more_data", &var->more_data);
        serialize< double >(a, "yet_more_data", &var->yet_more_data);
        serialize< TestEnum_e >(a, "ste", &var->ste);
        serialize< TestStruct >(a, "ts", &var->ts);
        serialize< TestTpl<uint32_t> >(a, "ttpl", &var->ttpl);
    }
    static void s(Archive< Stream > &a, const char* name, ThisIsATest *var, size_t num)
    {
        a(name, var, num);
    }
};
} // end namespace c4
/** imgui: auto-generated from main.hpp:100: C4_CLASS: ThisIsATest */


// ThisIsATest
/** enum: auto-generated from main.hpp:103: C4_ENUM: ThisIsATest::TTestEnum_e */
#include "enum.hpp"

template<> const EnumSymbols< ThisIsATest::TTestEnum_e > esyms();
template<> inline size_t eoffs_pfx< ThisIsATest::TTestEnum_e >()
{
    // same as strlen("ThisIsATest::CE_")
    return 16;
}

























#endif // _MAIN_GEN_HPP_